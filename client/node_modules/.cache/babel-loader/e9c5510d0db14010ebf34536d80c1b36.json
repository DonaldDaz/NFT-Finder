{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _extends = require('@babel/runtime/helpers/extends');\n\nvar _inheritsLoose = require('@babel/runtime/helpers/inheritsLoose');\n\nvar React = require('react');\n\nvar PropTypes = require('prop-types');\n\nfunction _interopDefault(e) {\n  return e && e.__esModule ? e : {\n    'default': e\n  };\n}\n\nvar _extends__default = /*#__PURE__*/_interopDefault(_extends);\n\nvar _inheritsLoose__default = /*#__PURE__*/_interopDefault(_inheritsLoose);\n\nvar React__default = /*#__PURE__*/_interopDefault(React);\n\nvar PropTypes__default = /*#__PURE__*/_interopDefault(PropTypes);\n\nvar _jsxFileName = \"/Users/krise/github/react-slider/src/components/ReactSlider/ReactSlider.jsx\";\n/**\n * To prevent text selection while dragging.\n * http://stackoverflow.com/questions/5429827/how-can-i-prevent-text-element-selection-with-cursor-drag\n */\n\nfunction pauseEvent(e) {\n  if (e && e.stopPropagation) {\n    e.stopPropagation();\n  }\n\n  if (e && e.preventDefault) {\n    e.preventDefault();\n  }\n\n  return false;\n}\n\nfunction stopPropagation(e) {\n  if (e.stopPropagation) {\n    e.stopPropagation();\n  }\n}\n\nfunction sanitizeInValue(x) {\n  if (x == null) {\n    return [];\n  }\n\n  return Array.isArray(x) ? x.slice() : [x];\n}\n\nfunction prepareOutValue(x) {\n  return x !== null && x.length === 1 ? x[0] : x.slice();\n}\n\nfunction trimSucceeding(length, nextValue, minDistance, max) {\n  for (let i = 0; i < length; i += 1) {\n    const padding = max - i * minDistance;\n\n    if (nextValue[length - 1 - i] > padding) {\n      // eslint-disable-next-line no-param-reassign\n      nextValue[length - 1 - i] = padding;\n    }\n  }\n}\n\nfunction trimPreceding(length, nextValue, minDistance, min) {\n  for (let i = 0; i < length; i += 1) {\n    const padding = min + i * minDistance;\n\n    if (nextValue[i] < padding) {\n      // eslint-disable-next-line no-param-reassign\n      nextValue[i] = padding;\n    }\n  }\n}\n\nfunction addHandlers(eventMap) {\n  Object.keys(eventMap).forEach(key => {\n    if (typeof document !== 'undefined') {\n      document.addEventListener(key, eventMap[key], false);\n    }\n  });\n}\n\nfunction removeHandlers(eventMap) {\n  Object.keys(eventMap).forEach(key => {\n    if (typeof document !== 'undefined') {\n      document.removeEventListener(key, eventMap[key], false);\n    }\n  });\n}\n\nfunction trimAlignValue(val, props) {\n  return alignValue(trimValue(val, props), props);\n}\n\nfunction alignValue(val, props) {\n  const valModStep = (val - props.min) % props.step;\n  let alignedValue = val - valModStep;\n\n  if (Math.abs(valModStep) * 2 >= props.step) {\n    alignedValue += valModStep > 0 ? props.step : -props.step;\n  }\n\n  return parseFloat(alignedValue.toFixed(5));\n}\n\nfunction trimValue(val, props) {\n  let trimmed = val;\n\n  if (trimmed <= props.min) {\n    trimmed = props.min;\n  }\n\n  if (trimmed >= props.max) {\n    trimmed = props.max;\n  }\n\n  return trimmed;\n}\n\nlet ReactSlider = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose__default[\"default\"](ReactSlider, _React$Component);\n\n  function ReactSlider(_props) {\n    var _this;\n\n    _this = _React$Component.call(this, _props) || this;\n\n    _this.onKeyUp = () => {\n      _this.onEnd();\n    };\n\n    _this.onMouseUp = () => {\n      _this.onEnd(_this.getMouseEventMap());\n    };\n\n    _this.onTouchEnd = () => {\n      _this.onEnd(_this.getTouchEventMap());\n    };\n\n    _this.onBlur = () => {\n      _this.setState({\n        index: -1\n      }, _this.onEnd(_this.getKeyDownEventMap()));\n    };\n\n    _this.onMouseMove = e => {\n      // Prevent controlled updates from happening while mouse is moving\n      _this.setState({\n        pending: true\n      });\n\n      const position = _this.getMousePosition(e);\n\n      const diffPosition = _this.getDiffPosition(position[0]);\n\n      const newValue = _this.getValueFromPosition(diffPosition);\n\n      _this.move(newValue);\n    };\n\n    _this.onTouchMove = e => {\n      if (e.touches.length > 1) {\n        return;\n      } // Prevent controlled updates from happending while touch is moving\n\n\n      _this.setState({\n        pending: true\n      });\n\n      const position = _this.getTouchPosition(e);\n\n      if (typeof _this.isScrolling === 'undefined') {\n        const diffMainDir = position[0] - _this.startPosition[0];\n        const diffScrollDir = position[1] - _this.startPosition[1];\n        _this.isScrolling = Math.abs(diffScrollDir) > Math.abs(diffMainDir);\n      }\n\n      if (_this.isScrolling) {\n        _this.setState({\n          index: -1\n        });\n\n        return;\n      }\n\n      const diffPosition = _this.getDiffPosition(position[0]);\n\n      const newValue = _this.getValueFromPosition(diffPosition);\n\n      _this.move(newValue);\n    };\n\n    _this.onKeyDown = e => {\n      if (e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) {\n        return;\n      } // Prevent controlled updates from happening while a key is pressed\n\n\n      _this.setState({\n        pending: true\n      });\n\n      switch (e.key) {\n        case 'ArrowLeft':\n        case 'ArrowDown':\n        case 'Left':\n        case 'Down':\n          e.preventDefault();\n\n          _this.moveDownByStep();\n\n          break;\n\n        case 'ArrowRight':\n        case 'ArrowUp':\n        case 'Right':\n        case 'Up':\n          e.preventDefault();\n\n          _this.moveUpByStep();\n\n          break;\n\n        case 'Home':\n          e.preventDefault();\n\n          _this.move(_this.props.min);\n\n          break;\n\n        case 'End':\n          e.preventDefault();\n\n          _this.move(_this.props.max);\n\n          break;\n\n        case 'PageDown':\n          e.preventDefault();\n\n          _this.moveDownByStep(_this.props.pageFn(_this.props.step));\n\n          break;\n\n        case 'PageUp':\n          e.preventDefault();\n\n          _this.moveUpByStep(_this.props.pageFn(_this.props.step));\n\n          break;\n      }\n    };\n\n    _this.onSliderMouseDown = e => {\n      // do nothing if disabled or right click\n      if (_this.props.disabled || e.button === 2) {\n        return;\n      } // Prevent controlled updates from happening while mouse is moving\n\n\n      _this.setState({\n        pending: true\n      });\n\n      if (!_this.props.snapDragDisabled) {\n        const position = _this.getMousePosition(e);\n\n        _this.forceValueFromPosition(position[0], i => {\n          _this.start(i, position[0]);\n\n          addHandlers(_this.getMouseEventMap());\n        });\n      }\n\n      pauseEvent(e);\n    };\n\n    _this.onSliderClick = e => {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      if (_this.props.onSliderClick && !_this.hasMoved) {\n        const position = _this.getMousePosition(e);\n\n        const valueAtPos = trimAlignValue(_this.calcValue(_this.calcOffsetFromPosition(position[0])), _this.props);\n\n        _this.props.onSliderClick(valueAtPos);\n      }\n    };\n\n    _this.createOnKeyDown = i => e => {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      _this.start(i);\n\n      addHandlers(_this.getKeyDownEventMap());\n      pauseEvent(e);\n    };\n\n    _this.createOnMouseDown = i => e => {\n      // do nothing if disabled or right click\n      if (_this.props.disabled || e.button === 2) {\n        return;\n      } // Prevent controlled updates from happending while mouse is moving\n\n\n      _this.setState({\n        pending: true\n      });\n\n      const position = _this.getMousePosition(e);\n\n      _this.start(i, position[0]);\n\n      addHandlers(_this.getMouseEventMap());\n      pauseEvent(e);\n    };\n\n    _this.createOnTouchStart = i => e => {\n      if (_this.props.disabled || e.touches.length > 1) {\n        return;\n      } // Prevent controlled updates from happending while touch is moving\n\n\n      _this.setState({\n        pending: true\n      });\n\n      const position = _this.getTouchPosition(e);\n\n      _this.startPosition = position; // don't know yet if the user is trying to scroll\n\n      _this.isScrolling = undefined;\n\n      _this.start(i, position[0]);\n\n      addHandlers(_this.getTouchEventMap());\n      stopPropagation(e);\n    };\n\n    _this.handleResize = () => {\n      // setTimeout of 0 gives element enough time to have assumed its new size if\n      // it is being resized\n      const resizeTimeout = window.setTimeout(() => {\n        // drop this timeout from pendingResizeTimeouts to reduce memory usage\n        _this.pendingResizeTimeouts.shift();\n\n        _this.resize();\n      }, 0);\n\n      _this.pendingResizeTimeouts.push(resizeTimeout);\n    };\n\n    _this.renderThumb = (style, i) => {\n      const className = _this.props.thumbClassName + \" \" + _this.props.thumbClassName + \"-\" + i + \" \" + (_this.state.index === i ? _this.props.thumbActiveClassName : '');\n      const props = {\n        'ref': r => {\n          _this[\"thumb\" + i] = r;\n        },\n        'key': _this.props.thumbClassName + \"-\" + i,\n        className,\n        style,\n        'onMouseDown': _this.createOnMouseDown(i),\n        'onTouchStart': _this.createOnTouchStart(i),\n        'onFocus': _this.createOnKeyDown(i),\n        'tabIndex': 0,\n        'role': 'slider',\n        'aria-orientation': _this.props.orientation,\n        'aria-valuenow': _this.state.value[i],\n        'aria-valuemin': _this.props.min,\n        'aria-valuemax': _this.props.max,\n        'aria-label': Array.isArray(_this.props.ariaLabel) ? _this.props.ariaLabel[i] : _this.props.ariaLabel,\n        'aria-labelledby': Array.isArray(_this.props.ariaLabelledby) ? _this.props.ariaLabelledby[i] : _this.props.ariaLabelledby\n      };\n      const state = {\n        index: i,\n        value: prepareOutValue(_this.state.value),\n        valueNow: _this.state.value[i]\n      };\n\n      if (_this.props.ariaValuetext) {\n        props['aria-valuetext'] = typeof _this.props.ariaValuetext === 'string' ? _this.props.ariaValuetext : _this.props.ariaValuetext(state);\n      }\n\n      return _this.props.renderThumb(props, state);\n    };\n\n    _this.renderTrack = (i, offsetFrom, offsetTo) => {\n      const props = {\n        key: _this.props.trackClassName + \"-\" + i,\n        className: _this.props.trackClassName + \" \" + _this.props.trackClassName + \"-\" + i,\n        style: _this.buildTrackStyle(offsetFrom, _this.state.upperBound - offsetTo)\n      };\n      const state = {\n        index: i,\n        value: prepareOutValue(_this.state.value)\n      };\n      return _this.props.renderTrack(props, state);\n    };\n\n    let value = sanitizeInValue(_props.value);\n\n    if (!value.length) {\n      value = sanitizeInValue(_props.defaultValue);\n    } // array for storing resize timeouts ids\n\n\n    _this.pendingResizeTimeouts = [];\n    const zIndices = [];\n\n    for (let i = 0; i < value.length; i += 1) {\n      value[i] = trimAlignValue(value[i], _props);\n      zIndices.push(i);\n    }\n\n    _this.resizeObserver = null;\n    _this.resizeElementRef = /*#__PURE__*/React__default[\"default\"].createRef();\n    _this.state = {\n      index: -1,\n      upperBound: 0,\n      sliderLength: 0,\n      value,\n      zIndices\n    };\n    return _this;\n  }\n\n  var _proto = ReactSlider.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    if (typeof window !== 'undefined') {\n      this.resizeObserver = new ResizeObserver(this.handleResize);\n      this.resizeObserver.observe(this.resizeElementRef.current);\n      this.resize();\n    }\n  } // Keep the internal `value` consistent with an outside `value` if present.\n  // This basically allows the slider to be a controlled component.\n  ;\n\n  ReactSlider.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    const value = sanitizeInValue(props.value);\n\n    if (!value.length) {\n      return null;\n    } // Do not allow controlled upates to happen while we have pending updates\n\n\n    if (state.pending) {\n      return null;\n    }\n\n    return {\n      value: value.map(item => trimAlignValue(item, props))\n    };\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    // If an upperBound has not yet been determined (due to the component being hidden\n    // during the mount event, or during the last resize), then calculate it now\n    if (this.state.upperBound === 0) {\n      this.resize();\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.clearPendingResizeTimeouts();\n\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n  };\n\n  _proto.onEnd = function onEnd(eventMap) {\n    if (eventMap) {\n      removeHandlers(eventMap);\n    }\n\n    if (this.hasMoved) {\n      this.fireChangeEvent('onAfterChange');\n    } // Allow controlled updates to continue\n\n\n    this.setState({\n      pending: false\n    });\n    this.hasMoved = false;\n  };\n\n  _proto.getValue = function getValue() {\n    return prepareOutValue(this.state.value);\n  };\n\n  _proto.getClosestIndex = function getClosestIndex(pixelOffset) {\n    let minDist = Number.MAX_VALUE;\n    let closestIndex = -1;\n    const {\n      value\n    } = this.state;\n    const l = value.length;\n\n    for (let i = 0; i < l; i += 1) {\n      const offset = this.calcOffset(value[i]);\n      const dist = Math.abs(pixelOffset - offset);\n\n      if (dist < minDist) {\n        minDist = dist;\n        closestIndex = i;\n      }\n    }\n\n    return closestIndex;\n  };\n\n  _proto.getMousePosition = function getMousePosition(e) {\n    return [e[\"page\" + this.axisKey()], e[\"page\" + this.orthogonalAxisKey()]];\n  };\n\n  _proto.getTouchPosition = function getTouchPosition(e) {\n    const touch = e.touches[0];\n    return [touch[\"page\" + this.axisKey()], touch[\"page\" + this.orthogonalAxisKey()]];\n  };\n\n  _proto.getKeyDownEventMap = function getKeyDownEventMap() {\n    return {\n      keydown: this.onKeyDown,\n      keyup: this.onKeyUp,\n      focusout: this.onBlur\n    };\n  };\n\n  _proto.getMouseEventMap = function getMouseEventMap() {\n    return {\n      mousemove: this.onMouseMove,\n      mouseup: this.onMouseUp\n    };\n  };\n\n  _proto.getTouchEventMap = function getTouchEventMap() {\n    return {\n      touchmove: this.onTouchMove,\n      touchend: this.onTouchEnd\n    };\n  };\n\n  _proto.getValueFromPosition = function getValueFromPosition(position) {\n    const diffValue = position / (this.state.sliderLength - this.state.thumbSize) * (this.props.max - this.props.min);\n    return trimAlignValue(this.state.startValue + diffValue, this.props);\n  };\n\n  _proto.getDiffPosition = function getDiffPosition(position) {\n    let diffPosition = position - this.state.startPosition;\n\n    if (this.props.invert) {\n      diffPosition *= -1;\n    }\n\n    return diffPosition;\n  } // create the `keydown` handler for the i-th thumb\n  ;\n\n  _proto.resize = function resize() {\n    const {\n      slider,\n      thumb0: thumb\n    } = this;\n\n    if (!slider || !thumb) {\n      return;\n    }\n\n    const sizeKey = this.sizeKey(); // For the slider size, we want to use the client width/height, excluding any borders\n\n    const sliderRect = slider.getBoundingClientRect();\n    const sliderSize = slider[sizeKey];\n    const sliderMax = sliderRect[this.posMaxKey()];\n    const sliderMin = sliderRect[this.posMinKey()]; // For the thumb size, we want to use the outer width/height, including any borders\n\n    const thumbRect = thumb.getBoundingClientRect();\n    const thumbSize = thumbRect[sizeKey.replace('client', '').toLowerCase()];\n    const upperBound = sliderSize - thumbSize;\n    const sliderLength = Math.abs(sliderMax - sliderMin);\n\n    if (this.state.upperBound !== upperBound || this.state.sliderLength !== sliderLength || this.state.thumbSize !== thumbSize) {\n      this.setState({\n        upperBound,\n        sliderLength,\n        thumbSize\n      });\n    }\n  } // calculates the offset of a thumb in pixels based on its value.\n  ;\n\n  _proto.calcOffset = function calcOffset(value) {\n    const range = this.props.max - this.props.min;\n\n    if (range === 0) {\n      return 0;\n    }\n\n    const ratio = (value - this.props.min) / range;\n    return ratio * this.state.upperBound;\n  } // calculates the value corresponding to a given pixel offset, i.e. the inverse of `calcOffset`.\n  ;\n\n  _proto.calcValue = function calcValue(offset) {\n    const ratio = offset / this.state.upperBound;\n    return ratio * (this.props.max - this.props.min) + this.props.min;\n  };\n\n  _proto.calcOffsetFromPosition = function calcOffsetFromPosition(position) {\n    const {\n      slider\n    } = this;\n    const sliderRect = slider.getBoundingClientRect();\n    const sliderMax = sliderRect[this.posMaxKey()];\n    const sliderMin = sliderRect[this.posMinKey()]; // The `position` value passed in is the mouse position based on the window height.\n    // The slider bounding rect is based on the viewport, so we must add the window scroll\n    // offset to normalize the values.\n\n    const windowOffset = window[\"page\" + this.axisKey() + \"Offset\"];\n    const sliderStart = windowOffset + (this.props.invert ? sliderMax : sliderMin);\n    let pixelOffset = position - sliderStart;\n\n    if (this.props.invert) {\n      pixelOffset = this.state.sliderLength - pixelOffset;\n    }\n\n    pixelOffset -= this.state.thumbSize / 2;\n    return pixelOffset;\n  } // Snaps the nearest thumb to the value corresponding to `position`\n  // and calls `callback` with that thumb's index.\n  ;\n\n  _proto.forceValueFromPosition = function forceValueFromPosition(position, callback) {\n    const pixelOffset = this.calcOffsetFromPosition(position);\n    const closestIndex = this.getClosestIndex(pixelOffset);\n    const nextValue = trimAlignValue(this.calcValue(pixelOffset), this.props); // Clone this.state.value since we'll modify it temporarily\n    // eslint-disable-next-line zillow/react/no-access-state-in-setstate\n\n    const value = this.state.value.slice();\n    value[closestIndex] = nextValue; // Prevents the slider from shrinking below `props.minDistance`\n\n    for (let i = 0; i < value.length - 1; i += 1) {\n      if (value[i + 1] - value[i] < this.props.minDistance) {\n        return;\n      }\n    }\n\n    this.fireChangeEvent('onBeforeChange');\n    this.hasMoved = true;\n    this.setState({\n      value\n    }, () => {\n      callback(closestIndex);\n      this.fireChangeEvent('onChange');\n    });\n  } // clear all pending timeouts to avoid error messages after unmounting\n  ;\n\n  _proto.clearPendingResizeTimeouts = function clearPendingResizeTimeouts() {\n    do {\n      const nextTimeout = this.pendingResizeTimeouts.shift();\n      clearTimeout(nextTimeout);\n    } while (this.pendingResizeTimeouts.length);\n  };\n\n  _proto.start = function start(i, position) {\n    const thumbRef = this[\"thumb\" + i];\n\n    if (thumbRef) {\n      thumbRef.focus();\n    }\n\n    const {\n      zIndices\n    } = this.state; // remove wherever the element is\n\n    zIndices.splice(zIndices.indexOf(i), 1); // add to end\n\n    zIndices.push(i);\n    this.setState(prevState => ({\n      startValue: prevState.value[i],\n      startPosition: position !== undefined ? position : prevState.startPosition,\n      index: i,\n      zIndices\n    }));\n  };\n\n  _proto.moveUpByStep = function moveUpByStep(step) {\n    if (step === void 0) {\n      step = this.props.step;\n    }\n\n    const oldValue = this.state.value[this.state.index];\n    const newValue = trimAlignValue(oldValue + step, this.props);\n    this.move(Math.min(newValue, this.props.max));\n  };\n\n  _proto.moveDownByStep = function moveDownByStep(step) {\n    if (step === void 0) {\n      step = this.props.step;\n    }\n\n    const oldValue = this.state.value[this.state.index];\n    const newValue = trimAlignValue(oldValue - step, this.props);\n    this.move(Math.max(newValue, this.props.min));\n  };\n\n  _proto.move = function move(newValue) {\n    const {\n      index,\n      value\n    } = this.state;\n    const {\n      length\n    } = value; // Short circuit if the value is not changing\n\n    const oldValue = value[index];\n\n    if (newValue === oldValue) {\n      return;\n    } // Trigger only before the first movement\n\n\n    if (!this.hasMoved) {\n      this.fireChangeEvent('onBeforeChange');\n    }\n\n    this.hasMoved = true; // if \"pearling\" (= thumbs pushing each other) is disabled,\n    // prevent the thumb from getting closer than `minDistance` to the previous or next thumb.\n\n    const {\n      pearling,\n      max,\n      min,\n      minDistance\n    } = this.props;\n\n    if (!pearling) {\n      if (index > 0) {\n        const valueBefore = value[index - 1];\n\n        if (newValue < valueBefore + minDistance) {\n          // eslint-disable-next-line no-param-reassign\n          newValue = valueBefore + minDistance;\n        }\n      }\n\n      if (index < length - 1) {\n        const valueAfter = value[index + 1];\n\n        if (newValue > valueAfter - minDistance) {\n          // eslint-disable-next-line no-param-reassign\n          newValue = valueAfter - minDistance;\n        }\n      }\n    }\n\n    value[index] = newValue; // if \"pearling\" is enabled, let the current thumb push the pre- and succeeding thumbs.\n\n    if (pearling && length > 1) {\n      if (newValue > oldValue) {\n        this.pushSucceeding(value, minDistance, index);\n        trimSucceeding(length, value, minDistance, max);\n      } else if (newValue < oldValue) {\n        this.pushPreceding(value, minDistance, index);\n        trimPreceding(length, value, minDistance, min);\n      }\n    } // Normally you would use `shouldComponentUpdate`,\n    // but since the slider is a low-level component,\n    // the extra complexity might be worth the extra performance.\n\n\n    this.setState({\n      value\n    }, this.fireChangeEvent.bind(this, 'onChange'));\n  };\n\n  _proto.pushSucceeding = function pushSucceeding(value, minDistance, index) {\n    let i;\n    let padding;\n\n    for (i = index, padding = value[i] + minDistance; value[i + 1] !== null && padding > value[i + 1]; i += 1, padding = value[i] + minDistance) {\n      // eslint-disable-next-line no-param-reassign\n      value[i + 1] = alignValue(padding, this.props);\n    }\n  };\n\n  _proto.pushPreceding = function pushPreceding(value, minDistance, index) {\n    for (let i = index, padding = value[i] - minDistance; value[i - 1] !== null && padding < value[i - 1]; i -= 1, padding = value[i] - minDistance) {\n      // eslint-disable-next-line no-param-reassign\n      value[i - 1] = alignValue(padding, this.props);\n    }\n  };\n\n  _proto.axisKey = function axisKey() {\n    if (this.props.orientation === 'vertical') {\n      return 'Y';\n    } // Defaults to 'horizontal';\n\n\n    return 'X';\n  };\n\n  _proto.orthogonalAxisKey = function orthogonalAxisKey() {\n    if (this.props.orientation === 'vertical') {\n      return 'X';\n    } // Defaults to 'horizontal'\n\n\n    return 'Y';\n  };\n\n  _proto.posMinKey = function posMinKey() {\n    if (this.props.orientation === 'vertical') {\n      return this.props.invert ? 'bottom' : 'top';\n    } // Defaults to 'horizontal'\n\n\n    return this.props.invert ? 'right' : 'left';\n  };\n\n  _proto.posMaxKey = function posMaxKey() {\n    if (this.props.orientation === 'vertical') {\n      return this.props.invert ? 'top' : 'bottom';\n    } // Defaults to 'horizontal'\n\n\n    return this.props.invert ? 'left' : 'right';\n  };\n\n  _proto.sizeKey = function sizeKey() {\n    if (this.props.orientation === 'vertical') {\n      return 'clientHeight';\n    } // Defaults to 'horizontal'\n\n\n    return 'clientWidth';\n  };\n\n  _proto.fireChangeEvent = function fireChangeEvent(event) {\n    if (this.props[event]) {\n      this.props[event](prepareOutValue(this.state.value), this.state.index);\n    }\n  };\n\n  _proto.buildThumbStyle = function buildThumbStyle(offset, i) {\n    const style = {\n      position: 'absolute',\n      touchAction: 'none',\n      willChange: this.state.index >= 0 ? this.posMinKey() : undefined,\n      zIndex: this.state.zIndices.indexOf(i) + 1\n    };\n    style[this.posMinKey()] = offset + \"px\";\n    return style;\n  };\n\n  _proto.buildTrackStyle = function buildTrackStyle(min, max) {\n    const obj = {\n      position: 'absolute',\n      willChange: this.state.index >= 0 ? this.posMinKey() + \",\" + this.posMaxKey() : undefined\n    };\n    obj[this.posMinKey()] = min;\n    obj[this.posMaxKey()] = max;\n    return obj;\n  };\n\n  _proto.buildMarkStyle = function buildMarkStyle(offset) {\n    var _ref;\n\n    return _ref = {\n      position: 'absolute'\n    }, _ref[this.posMinKey()] = offset, _ref;\n  };\n\n  _proto.renderThumbs = function renderThumbs(offset) {\n    const {\n      length\n    } = offset;\n    const styles = [];\n\n    for (let i = 0; i < length; i += 1) {\n      styles[i] = this.buildThumbStyle(offset[i], i);\n    }\n\n    const res = [];\n\n    for (let i = 0; i < length; i += 1) {\n      res[i] = this.renderThumb(styles[i], i);\n    }\n\n    return res;\n  };\n\n  _proto.renderTracks = function renderTracks(offset) {\n    const tracks = [];\n    const lastIndex = offset.length - 1;\n    tracks.push(this.renderTrack(0, 0, offset[0]));\n\n    for (let i = 0; i < lastIndex; i += 1) {\n      tracks.push(this.renderTrack(i + 1, offset[i], offset[i + 1]));\n    }\n\n    tracks.push(this.renderTrack(lastIndex + 1, offset[lastIndex], this.state.upperBound));\n    return tracks;\n  };\n\n  _proto.renderMarks = function renderMarks() {\n    let {\n      marks\n    } = this.props;\n    const range = this.props.max - this.props.min + 1;\n\n    if (typeof marks === 'boolean') {\n      marks = Array.from({\n        length: range\n      }).map((_, key) => key);\n    } else if (typeof marks === 'number') {\n      marks = Array.from({\n        length: range\n      }).map((_, key) => key).filter(key => key % marks === 0);\n    }\n\n    return marks.map(parseFloat).sort((a, b) => a - b).map(mark => {\n      const offset = this.calcOffset(mark);\n      const props = {\n        key: mark,\n        className: this.props.markClassName,\n        style: this.buildMarkStyle(offset)\n      };\n      return this.props.renderMark(props);\n    });\n  };\n\n  _proto.render = function render() {\n    const offset = [];\n    const {\n      value\n    } = this.state;\n    const l = value.length;\n\n    for (let i = 0; i < l; i += 1) {\n      offset[i] = this.calcOffset(value[i], i);\n    }\n\n    const tracks = this.props.withTracks ? this.renderTracks(offset) : null;\n    const thumbs = this.renderThumbs(offset);\n    const marks = this.props.marks ? this.renderMarks() : null;\n    return /*#__PURE__*/React__default[\"default\"].createElement('div', {\n      ref: r => {\n        this.slider = r;\n        this.resizeElementRef.current = r;\n      },\n      style: {\n        position: 'relative'\n      },\n      className: this.props.className + (this.props.disabled ? ' disabled' : ''),\n      onMouseDown: this.onSliderMouseDown,\n      onClick: this.onSliderClick\n    }, tracks, thumbs, marks);\n  };\n\n  return ReactSlider;\n}(React__default[\"default\"].Component);\n\nReactSlider.displayName = 'ReactSlider';\nReactSlider.defaultProps = {\n  min: 0,\n  max: 100,\n  step: 1,\n  pageFn: step => step * 10,\n  minDistance: 0,\n  defaultValue: 0,\n  orientation: 'horizontal',\n  className: 'slider',\n  thumbClassName: 'thumb',\n  thumbActiveClassName: 'active',\n  trackClassName: 'track',\n  markClassName: 'mark',\n  withTracks: true,\n  pearling: false,\n  disabled: false,\n  snapDragDisabled: false,\n  invert: false,\n  marks: [],\n  renderThumb: props => /*#__PURE__*/React__default[\"default\"].createElement(\"div\", _extends__default[\"default\"]({}, props, {\n    __self: ReactSlider,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 353,\n      columnNumber: 31\n    }\n  })),\n  renderTrack: props => /*#__PURE__*/React__default[\"default\"].createElement(\"div\", _extends__default[\"default\"]({}, props, {\n    __self: ReactSlider,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 354,\n      columnNumber: 31\n    }\n  })),\n  renderMark: props => /*#__PURE__*/React__default[\"default\"].createElement(\"span\", _extends__default[\"default\"]({}, props, {\n    __self: ReactSlider,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 355,\n      columnNumber: 30\n    }\n  }))\n};\nReactSlider.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * The minimum value of the slider.\n   */\n  min: PropTypes__default[\"default\"].number,\n\n  /**\n   * The maximum value of the slider.\n   */\n  max: PropTypes__default[\"default\"].number,\n\n  /**\n   * Value to be added or subtracted on each step the slider makes.\n   * Must be greater than zero.\n   * `max - min` should be evenly divisible by the step value.\n   */\n  step: PropTypes__default[\"default\"].number,\n\n  /**\n   * The result of the function is the value to be added or subtracted\n   * when the `Page Up` or `Page Down` keys are pressed.\n   *\n   * The current `step` value will be passed as the only argument.\n   * By default, paging will modify `step` by a factor of 10.\n   */\n  pageFn: PropTypes__default[\"default\"].func,\n\n  /**\n   * The minimal distance between any pair of thumbs.\n   * Must be positive, but zero means they can sit on top of each other.\n   */\n  minDistance: PropTypes__default[\"default\"].number,\n\n  /**\n   * Determines the initial positions of the thumbs and the number of thumbs.\n   *\n   * If a number is passed a slider with one thumb will be rendered.\n   * If an array is passed each value will determine the position of one thumb.\n   * The values in the array must be sorted.\n   */\n  defaultValue: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].number, PropTypes__default[\"default\"].arrayOf(PropTypes__default[\"default\"].number)]),\n\n  /**\n   * Like `defaultValue` but for\n   * [controlled components](http://facebook.github.io/react/docs/forms.html#controlled-components).\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  value: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].number, PropTypes__default[\"default\"].arrayOf(PropTypes__default[\"default\"].number)]),\n\n  /**\n   * Determines whether the slider moves horizontally (from left to right)\n   * or vertically (from top to bottom).\n   */\n  orientation: PropTypes__default[\"default\"].oneOf(['horizontal', 'vertical']),\n\n  /**\n   * The css class set on the slider node.\n   */\n  className: PropTypes__default[\"default\"].string,\n\n  /**\n   * The css class set on each thumb node.\n   *\n   * In addition each thumb will receive a numbered css class of the form\n   * `${thumbClassName}-${i}`, e.g. `thumb-0`, `thumb-1`, ...\n   */\n  thumbClassName: PropTypes__default[\"default\"].string,\n\n  /**\n   * The css class set on the thumb that is currently being moved.\n   */\n  thumbActiveClassName: PropTypes__default[\"default\"].string,\n\n  /**\n   * If `true` tracks between the thumbs will be rendered.\n   */\n  withTracks: PropTypes__default[\"default\"].bool,\n\n  /**\n   * The css class set on the tracks between the thumbs.\n   * In addition track fragment will receive a numbered css class of the form\n   * `${trackClassName}-${i}`, e.g. `track-0`, `track-1`, ...\n   */\n  trackClassName: PropTypes__default[\"default\"].string,\n\n  /**\n   * If `true` the active thumb will push other thumbs\n   * within the constraints of `min`, `max`, `step` and `minDistance`.\n   */\n  pearling: PropTypes__default[\"default\"].bool,\n\n  /**\n   * If `true` the thumbs can't be moved.\n   */\n  disabled: PropTypes__default[\"default\"].bool,\n\n  /**\n   * Disables thumb move when clicking the slider track\n   */\n  snapDragDisabled: PropTypes__default[\"default\"].bool,\n\n  /**\n   * Inverts the slider.\n   */\n  invert: PropTypes__default[\"default\"].bool,\n\n  /**\n   * Shows passed marks on the track, if true it shows all the marks,\n   * if an array of numbers it shows just the passed marks, if a number is passed\n   * it shows just the marks in that steps: like passing 3 shows the marks 3, 6, 9\n   */\n  marks: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].arrayOf(PropTypes__default[\"default\"].number), PropTypes__default[\"default\"].bool, PropTypes__default[\"default\"].number]),\n\n  /**\n   * The css class set on the marks.\n   */\n  markClassName: PropTypes__default[\"default\"].string,\n\n  /**\n   * Callback called before starting to move a thumb. The callback will only be called if the\n   * action will result in a change. The function will be called with two arguments, the first\n   * being the initial value(s) the second being thumb index.\n   */\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n  onBeforeChange: PropTypes__default[\"default\"].func,\n\n  /**\n   * Callback called on every value change.\n   * The function will be called with two arguments, the first being the new value(s)\n   * the second being thumb index.\n   */\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n  onChange: PropTypes__default[\"default\"].func,\n\n  /**\n   * Callback called only after moving a thumb has ended. The callback will only be called if\n   * the action resulted in a change. The function will be called with two arguments, the\n   * first being the result value(s) the second being thumb index.\n   */\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n  onAfterChange: PropTypes__default[\"default\"].func,\n\n  /**\n   * Callback called when the the slider is clicked (thumb or tracks).\n   * Receives the value at the clicked position as argument.\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  onSliderClick: PropTypes__default[\"default\"].func,\n\n  /**\n   * aria-label for screen-readers to apply to the thumbs.\n   * Use an array for more than one thumb.\n   * The length of the array must match the number of thumbs in the value array.\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  ariaLabel: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].arrayOf(PropTypes__default[\"default\"].string)]),\n\n  /**\n   * aria-labelledby for screen-readers to apply to the thumbs.\n   * Used when slider rendered with separate label.\n   * Use an array for more than one thumb.\n   * The length of the array must match the number of thumbs in the value array.\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  ariaLabelledby: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].arrayOf(PropTypes__default[\"default\"].string)]),\n\n  /**\n   * aria-valuetext for screen-readers.\n   * Can be a static string, or a function that returns a string.\n   * The function will be passed a single argument,\n   * an object with the following properties:\n   *\n   *     state => `Value: ${state.value}`\n   *\n   * - `state.index` {`number`} the index of the thumb\n   * - `state.value` {`number` | `array`} the current value state\n   * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  ariaValuetext: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].func]),\n\n  /**\n   * Provide a custom render function for the track node.\n   * The render function will be passed two arguments,\n   * an object with props that should be added to your handle node,\n   * and an object with track and slider state:\n   *\n   *     (props, state) => <div {...props} />\n   *\n   * - `props` {`object`} props to be spread into your track node\n   * - `state.index` {`number`} the index of the track\n   * - `state.value` {`number` | `array`} the current value state\n   */\n  renderTrack: PropTypes__default[\"default\"].func,\n\n  /**\n   * Provide a custom render function for dynamic thumb content.\n   * The render function will be passed two arguments,\n   * an object with props that should be added to your thumb node,\n   * and an object with thumb and slider state:\n   *\n   *     (props, state) => <div {...props} />\n   *\n   * - `props` {`object`} props to be spread into your thumb node\n   * - `state.index` {`number`} the index of the thumb\n   * - `state.value` {`number` | `array`} the current value state\n   * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  renderThumb: PropTypes__default[\"default\"].func,\n\n  /**\n   * Provide a custom render function for the mark node.\n   * The render function will be passed one argument,\n   * an object with props that should be added to your handle node\n   *\n   *     (props) => <span {...props} />\n   *\n   * - `props` {`object`} props to be spread into your track node\n   */\n  renderMark: PropTypes__default[\"default\"].func\n} : {};\nvar ReactSlider$1 = ReactSlider;\nexports[\"default\"] = ReactSlider$1;","map":{"version":3,"sources":["../../../../../src/components/ReactSlider/ReactSlider.jsx"],"names":["e","x","Array","i","padding","max","nextValue","length","min","Object","key","document","eventMap","alignValue","trimValue","valModStep","val","props","alignedValue","Math","parseFloat","trimmed","ReactSlider","React","Component","displayName","propTypes","PropTypes","step","pageFn","minDistance","defaultValue","value","orientation","className","thumbClassName","thumbActiveClassName","withTracks","trackClassName","pearling","disabled","snapDragDisabled","invert","marks","markClassName","onBeforeChange","onChange","onAfterChange","onSliderClick","ariaLabel","ariaLabelledby","ariaValuetext","renderTrack","renderThumb","renderMark","func","defaultProps","sanitizeInValue","pendingResizeTimeouts","zIndices","trimAlignValue","resizeObserver","index","upperBound","sliderLength","componentDidMount","getDerivedStateFromProps","state","item","componentDidUpdate","componentWillUnmount","onKeyUp","onMouseUp","getMouseEventMap","onTouchEnd","getTouchEventMap","onBlur","onEnd","getKeyDownEventMap","removeHandlers","pending","onMouseMove","position","diffPosition","getDiffPosition","newValue","move","onTouchMove","diffMainDir","startPosition","diffScrollDir","onKeyDown","moveDownByStep","moveUpByStep","onSliderMouseDown","forceValueFromPosition","addHandlers","pauseEvent","valueAtPos","calcValue","calcOffsetFromPosition","getValue","prepareOutValue","getClosestIndex","pixelOffset","minDist","Number","closestIndex","l","offset","dist","getMousePosition","getTouchPosition","touch","keydown","keyup","focusout","mousemove","mouseup","touchmove","touchend","getValueFromPosition","diffValue","start","isScrolling","stopPropagation","handleResize","resizeTimeout","resize","thumb0","thumb","sizeKey","sliderRect","slider","sliderSize","sliderMax","sliderMin","thumbRect","thumbSize","calcOffset","range","ratio","windowOffset","window","sliderStart","callback","clearPendingResizeTimeouts","nextTimeout","clearTimeout","thumbRef","prevState","startValue","oldValue","valueBefore","valueAfter","trimSucceeding","trimPreceding","pushSucceeding","pushPreceding","axisKey","orthogonalAxisKey","posMinKey","posMaxKey","fireChangeEvent","event","buildThumbStyle","style","touchAction","willChange","zIndex","buildTrackStyle","obj","undefined","buildMarkStyle","r","createOnMouseDown","createOnTouchStart","createOnKeyDown","valueNow","renderThumbs","styles","res","renderTracks","tracks","lastIndex","renderMarks","a","mark","render","thumbs","ref","onMouseDown","onClick"],"mappings":"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","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\n\n/**\n * To prevent text selection while dragging.\n * http://stackoverflow.com/questions/5429827/how-can-i-prevent-text-element-selection-with-cursor-drag\n */\nfunction pauseEvent(e) {\n    if (e && e.stopPropagation) {\n        e.stopPropagation();\n    }\n    if (e && e.preventDefault) {\n        e.preventDefault();\n    }\n    return false;\n}\n\nfunction stopPropagation(e) {\n    if (e.stopPropagation) {\n        e.stopPropagation();\n    }\n}\n\nfunction sanitizeInValue(x) {\n    if (x == null) {\n        return [];\n    }\n    return Array.isArray(x) ? x.slice() : [x];\n}\n\nfunction prepareOutValue(x) {\n    return x !== null && x.length === 1 ? x[0] : x.slice();\n}\n\nfunction trimSucceeding(length, nextValue, minDistance, max) {\n    for (let i = 0; i < length; i += 1) {\n        const padding = max - i * minDistance;\n        if (nextValue[length - 1 - i] > padding) {\n            // eslint-disable-next-line no-param-reassign\n            nextValue[length - 1 - i] = padding;\n        }\n    }\n}\n\nfunction trimPreceding(length, nextValue, minDistance, min) {\n    for (let i = 0; i < length; i += 1) {\n        const padding = min + i * minDistance;\n        if (nextValue[i] < padding) {\n            // eslint-disable-next-line no-param-reassign\n            nextValue[i] = padding;\n        }\n    }\n}\n\nfunction addHandlers(eventMap) {\n    Object.keys(eventMap).forEach(key => {\n        if (typeof document !== 'undefined') {\n            document.addEventListener(key, eventMap[key], false);\n        }\n    });\n}\n\nfunction removeHandlers(eventMap) {\n    Object.keys(eventMap).forEach(key => {\n        if (typeof document !== 'undefined') {\n            document.removeEventListener(key, eventMap[key], false);\n        }\n    });\n}\n\nfunction trimAlignValue(val, props) {\n    return alignValue(trimValue(val, props), props);\n}\n\nfunction alignValue(val, props) {\n    const valModStep = (val - props.min) % props.step;\n    let alignedValue = val - valModStep;\n\n    if (Math.abs(valModStep) * 2 >= props.step) {\n        alignedValue += valModStep > 0 ? props.step : -props.step;\n    }\n\n    return parseFloat(alignedValue.toFixed(5));\n}\n\nfunction trimValue(val, props) {\n    let trimmed = val;\n    if (trimmed <= props.min) {\n        trimmed = props.min;\n    }\n    if (trimmed >= props.max) {\n        trimmed = props.max;\n    }\n\n    return trimmed;\n}\n\nclass ReactSlider extends React.Component {\n    static displayName = 'ReactSlider';\n\n    static propTypes = {\n        /**\n         * The minimum value of the slider.\n         */\n        min: PropTypes.number,\n\n        /**\n         * The maximum value of the slider.\n         */\n        max: PropTypes.number,\n\n        /**\n         * Value to be added or subtracted on each step the slider makes.\n         * Must be greater than zero.\n         * `max - min` should be evenly divisible by the step value.\n         */\n        step: PropTypes.number,\n\n        /**\n         * The result of the function is the value to be added or subtracted\n         * when the `Page Up` or `Page Down` keys are pressed.\n         *\n         * The current `step` value will be passed as the only argument.\n         * By default, paging will modify `step` by a factor of 10.\n         */\n        pageFn: PropTypes.func,\n\n        /**\n         * The minimal distance between any pair of thumbs.\n         * Must be positive, but zero means they can sit on top of each other.\n         */\n        minDistance: PropTypes.number,\n\n        /**\n         * Determines the initial positions of the thumbs and the number of thumbs.\n         *\n         * If a number is passed a slider with one thumb will be rendered.\n         * If an array is passed each value will determine the position of one thumb.\n         * The values in the array must be sorted.\n         */\n        defaultValue: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n\n        /**\n         * Like `defaultValue` but for\n         * [controlled components](http://facebook.github.io/react/docs/forms.html#controlled-components).\n         */\n        // eslint-disable-next-line zillow/react/require-default-props\n        value: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n\n        /**\n         * Determines whether the slider moves horizontally (from left to right)\n         * or vertically (from top to bottom).\n         */\n        orientation: PropTypes.oneOf(['horizontal', 'vertical']),\n\n        /**\n         * The css class set on the slider node.\n         */\n        className: PropTypes.string,\n\n        /**\n         * The css class set on each thumb node.\n         *\n         * In addition each thumb will receive a numbered css class of the form\n         * `${thumbClassName}-${i}`, e.g. `thumb-0`, `thumb-1`, ...\n         */\n        thumbClassName: PropTypes.string,\n\n        /**\n         * The css class set on the thumb that is currently being moved.\n         */\n        thumbActiveClassName: PropTypes.string,\n\n        /**\n         * If `true` tracks between the thumbs will be rendered.\n         */\n        withTracks: PropTypes.bool,\n\n        /**\n         * The css class set on the tracks between the thumbs.\n         * In addition track fragment will receive a numbered css class of the form\n         * `${trackClassName}-${i}`, e.g. `track-0`, `track-1`, ...\n         */\n        trackClassName: PropTypes.string,\n\n        /**\n         * If `true` the active thumb will push other thumbs\n         * within the constraints of `min`, `max`, `step` and `minDistance`.\n         */\n        pearling: PropTypes.bool,\n\n        /**\n         * If `true` the thumbs can't be moved.\n         */\n        disabled: PropTypes.bool,\n\n        /**\n         * Disables thumb move when clicking the slider track\n         */\n        snapDragDisabled: PropTypes.bool,\n\n        /**\n         * Inverts the slider.\n         */\n        invert: PropTypes.bool,\n\n        /**\n         * Shows passed marks on the track, if true it shows all the marks,\n         * if an array of numbers it shows just the passed marks, if a number is passed\n         * it shows just the marks in that steps: like passing 3 shows the marks 3, 6, 9\n         */\n        marks: PropTypes.oneOfType([\n            PropTypes.arrayOf(PropTypes.number),\n            PropTypes.bool,\n            PropTypes.number,\n        ]),\n\n        /**\n         * The css class set on the marks.\n         */\n        markClassName: PropTypes.string,\n\n        /**\n         * Callback called before starting to move a thumb. The callback will only be called if the\n         * action will result in a change. The function will be called with two arguments, the first\n         * being the initial value(s) the second being thumb index.\n         */\n        // eslint-disable-next-line max-len\n        // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n        onBeforeChange: PropTypes.func,\n\n        /**\n         * Callback called on every value change.\n         * The function will be called with two arguments, the first being the new value(s)\n         * the second being thumb index.\n         */\n        // eslint-disable-next-line max-len\n        // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n        onChange: PropTypes.func,\n\n        /**\n         * Callback called only after moving a thumb has ended. The callback will only be called if\n         * the action resulted in a change. The function will be called with two arguments, the\n         * first being the result value(s) the second being thumb index.\n         */\n        // eslint-disable-next-line max-len\n        // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n        onAfterChange: PropTypes.func,\n\n        /**\n         * Callback called when the the slider is clicked (thumb or tracks).\n         * Receives the value at the clicked position as argument.\n         */\n        // eslint-disable-next-line zillow/react/require-default-props\n        onSliderClick: PropTypes.func,\n\n        /**\n         * aria-label for screen-readers to apply to the thumbs.\n         * Use an array for more than one thumb.\n         * The length of the array must match the number of thumbs in the value array.\n         */\n        // eslint-disable-next-line zillow/react/require-default-props\n        ariaLabel: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n\n        /**\n         * aria-labelledby for screen-readers to apply to the thumbs.\n         * Used when slider rendered with separate label.\n         * Use an array for more than one thumb.\n         * The length of the array must match the number of thumbs in the value array.\n         */\n        // eslint-disable-next-line zillow/react/require-default-props\n        ariaLabelledby: PropTypes.oneOfType([\n            PropTypes.string,\n            PropTypes.arrayOf(PropTypes.string),\n        ]),\n\n        /**\n         * aria-valuetext for screen-readers.\n         * Can be a static string, or a function that returns a string.\n         * The function will be passed a single argument,\n         * an object with the following properties:\n         *\n         *     state => `Value: ${state.value}`\n         *\n         * - `state.index` {`number`} the index of the thumb\n         * - `state.value` {`number` | `array`} the current value state\n         * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\n         */\n        // eslint-disable-next-line zillow/react/require-default-props\n        ariaValuetext: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n\n        /**\n         * Provide a custom render function for the track node.\n         * The render function will be passed two arguments,\n         * an object with props that should be added to your handle node,\n         * and an object with track and slider state:\n         *\n         *     (props, state) => <div {...props} />\n         *\n         * - `props` {`object`} props to be spread into your track node\n         * - `state.index` {`number`} the index of the track\n         * - `state.value` {`number` | `array`} the current value state\n         */\n        renderTrack: PropTypes.func,\n\n        /**\n         * Provide a custom render function for dynamic thumb content.\n         * The render function will be passed two arguments,\n         * an object with props that should be added to your thumb node,\n         * and an object with thumb and slider state:\n         *\n         *     (props, state) => <div {...props} />\n         *\n         * - `props` {`object`} props to be spread into your thumb node\n         * - `state.index` {`number`} the index of the thumb\n         * - `state.value` {`number` | `array`} the current value state\n         * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\n         */\n        // eslint-disable-next-line zillow/react/require-default-props\n        renderThumb: PropTypes.func,\n\n        /**\n         * Provide a custom render function for the mark node.\n         * The render function will be passed one argument,\n         * an object with props that should be added to your handle node\n         *\n         *     (props) => <span {...props} />\n         *\n         * - `props` {`object`} props to be spread into your track node\n         */\n        renderMark: PropTypes.func,\n    };\n\n    static defaultProps = {\n        min: 0,\n        max: 100,\n        step: 1,\n        pageFn: step => step * 10,\n        minDistance: 0,\n        defaultValue: 0,\n        orientation: 'horizontal',\n        className: 'slider',\n        thumbClassName: 'thumb',\n        thumbActiveClassName: 'active',\n        trackClassName: 'track',\n        markClassName: 'mark',\n        withTracks: true,\n        pearling: false,\n        disabled: false,\n        snapDragDisabled: false,\n        invert: false,\n        marks: [],\n        renderThumb: props => <div {...props} />,\n        renderTrack: props => <div {...props} />,\n        renderMark: props => <span {...props} />,\n    };\n\n    constructor(props) {\n        super(props);\n\n        let value = sanitizeInValue(props.value);\n        if (!value.length) {\n            value = sanitizeInValue(props.defaultValue);\n        }\n\n        // array for storing resize timeouts ids\n        this.pendingResizeTimeouts = [];\n\n        const zIndices = [];\n        for (let i = 0; i < value.length; i += 1) {\n            value[i] = trimAlignValue(value[i], props);\n            zIndices.push(i);\n        }\n\n        this.resizeObserver = null;\n        this.resizeElementRef = React.createRef();\n\n        this.state = {\n            index: -1,\n            upperBound: 0,\n            sliderLength: 0,\n            value,\n            zIndices,\n        };\n    }\n\n    componentDidMount() {\n        if (typeof window !== 'undefined') {\n            this.resizeObserver = new ResizeObserver(this.handleResize);\n            this.resizeObserver.observe(this.resizeElementRef.current);\n            this.resize();\n        }\n    }\n\n    // Keep the internal `value` consistent with an outside `value` if present.\n    // This basically allows the slider to be a controlled component.\n    static getDerivedStateFromProps(props, state) {\n        const value = sanitizeInValue(props.value);\n        if (!value.length) {\n            return null;\n        }\n\n        // Do not allow controlled upates to happen while we have pending updates\n        if (state.pending) {\n            return null;\n        }\n\n        return {\n            value: value.map(item => trimAlignValue(item, props)),\n        };\n    }\n\n    componentDidUpdate() {\n        // If an upperBound has not yet been determined (due to the component being hidden\n        // during the mount event, or during the last resize), then calculate it now\n        if (this.state.upperBound === 0) {\n            this.resize();\n        }\n    }\n\n    componentWillUnmount() {\n        this.clearPendingResizeTimeouts();\n        if (this.resizeObserver) {\n            this.resizeObserver.disconnect();\n        }\n    }\n\n    onKeyUp = () => {\n        this.onEnd();\n    };\n\n    onMouseUp = () => {\n        this.onEnd(this.getMouseEventMap());\n    };\n\n    onTouchEnd = () => {\n        this.onEnd(this.getTouchEventMap());\n    };\n\n    onBlur = () => {\n        this.setState({ index: -1 }, this.onEnd(this.getKeyDownEventMap()));\n    };\n\n    onEnd(eventMap) {\n        if (eventMap) {\n            removeHandlers(eventMap);\n        }\n        if (this.hasMoved) {\n            this.fireChangeEvent('onAfterChange');\n        }\n\n        // Allow controlled updates to continue\n        this.setState({ pending: false });\n\n        this.hasMoved = false;\n    }\n\n    onMouseMove = e => {\n        // Prevent controlled updates from happening while mouse is moving\n        this.setState({ pending: true });\n\n        const position = this.getMousePosition(e);\n        const diffPosition = this.getDiffPosition(position[0]);\n        const newValue = this.getValueFromPosition(diffPosition);\n        this.move(newValue);\n    };\n\n    onTouchMove = e => {\n        if (e.touches.length > 1) {\n            return;\n        }\n\n        // Prevent controlled updates from happending while touch is moving\n        this.setState({ pending: true });\n\n        const position = this.getTouchPosition(e);\n\n        if (typeof this.isScrolling === 'undefined') {\n            const diffMainDir = position[0] - this.startPosition[0];\n            const diffScrollDir = position[1] - this.startPosition[1];\n            this.isScrolling = Math.abs(diffScrollDir) > Math.abs(diffMainDir);\n        }\n\n        if (this.isScrolling) {\n            this.setState({ index: -1 });\n            return;\n        }\n\n        const diffPosition = this.getDiffPosition(position[0]);\n        const newValue = this.getValueFromPosition(diffPosition);\n\n        this.move(newValue);\n    };\n\n    onKeyDown = e => {\n        if (e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) {\n            return;\n        }\n\n        // Prevent controlled updates from happening while a key is pressed\n        this.setState({ pending: true });\n\n        switch (e.key) {\n            case 'ArrowLeft':\n            case 'ArrowDown':\n            case 'Left':\n            case 'Down':\n                e.preventDefault();\n                this.moveDownByStep();\n                break;\n            case 'ArrowRight':\n            case 'ArrowUp':\n            case 'Right':\n            case 'Up':\n                e.preventDefault();\n                this.moveUpByStep();\n                break;\n            case 'Home':\n                e.preventDefault();\n                this.move(this.props.min);\n                break;\n            case 'End':\n                e.preventDefault();\n                this.move(this.props.max);\n                break;\n            case 'PageDown':\n                e.preventDefault();\n                this.moveDownByStep(this.props.pageFn(this.props.step));\n                break;\n            case 'PageUp':\n                e.preventDefault();\n                this.moveUpByStep(this.props.pageFn(this.props.step));\n                break;\n            default:\n        }\n    };\n\n    onSliderMouseDown = e => {\n        // do nothing if disabled or right click\n        if (this.props.disabled || e.button === 2) {\n            return;\n        }\n\n        // Prevent controlled updates from happening while mouse is moving\n        this.setState({ pending: true });\n\n        if (!this.props.snapDragDisabled) {\n            const position = this.getMousePosition(e);\n            this.forceValueFromPosition(position[0], i => {\n                this.start(i, position[0]);\n                addHandlers(this.getMouseEventMap());\n            });\n        }\n\n        pauseEvent(e);\n    };\n\n    onSliderClick = e => {\n        if (this.props.disabled) {\n            return;\n        }\n\n        if (this.props.onSliderClick && !this.hasMoved) {\n            const position = this.getMousePosition(e);\n            const valueAtPos = trimAlignValue(\n                this.calcValue(this.calcOffsetFromPosition(position[0])),\n                this.props\n            );\n            this.props.onSliderClick(valueAtPos);\n        }\n    };\n\n    getValue() {\n        return prepareOutValue(this.state.value);\n    }\n\n    getClosestIndex(pixelOffset) {\n        let minDist = Number.MAX_VALUE;\n        let closestIndex = -1;\n\n        const { value } = this.state;\n        const l = value.length;\n\n        for (let i = 0; i < l; i += 1) {\n            const offset = this.calcOffset(value[i]);\n            const dist = Math.abs(pixelOffset - offset);\n            if (dist < minDist) {\n                minDist = dist;\n                closestIndex = i;\n            }\n        }\n\n        return closestIndex;\n    }\n\n    getMousePosition(e) {\n        return [e[`page${this.axisKey()}`], e[`page${this.orthogonalAxisKey()}`]];\n    }\n\n    getTouchPosition(e) {\n        const touch = e.touches[0];\n        return [touch[`page${this.axisKey()}`], touch[`page${this.orthogonalAxisKey()}`]];\n    }\n\n    getKeyDownEventMap() {\n        return {\n            keydown: this.onKeyDown,\n            keyup: this.onKeyUp,\n            focusout: this.onBlur,\n        };\n    }\n\n    getMouseEventMap() {\n        return {\n            mousemove: this.onMouseMove,\n            mouseup: this.onMouseUp,\n        };\n    }\n\n    getTouchEventMap() {\n        return {\n            touchmove: this.onTouchMove,\n            touchend: this.onTouchEnd,\n        };\n    }\n\n    getValueFromPosition(position) {\n        const diffValue =\n            (position / (this.state.sliderLength - this.state.thumbSize)) *\n            (this.props.max - this.props.min);\n        return trimAlignValue(this.state.startValue + diffValue, this.props);\n    }\n\n    getDiffPosition(position) {\n        let diffPosition = position - this.state.startPosition;\n        if (this.props.invert) {\n            diffPosition *= -1;\n        }\n        return diffPosition;\n    }\n\n    // create the `keydown` handler for the i-th thumb\n    createOnKeyDown = i => e => {\n        if (this.props.disabled) {\n            return;\n        }\n        this.start(i);\n        addHandlers(this.getKeyDownEventMap());\n        pauseEvent(e);\n    };\n\n    // create the `mousedown` handler for the i-th thumb\n    createOnMouseDown = i => e => {\n        // do nothing if disabled or right click\n        if (this.props.disabled || e.button === 2) {\n            return;\n        }\n\n        // Prevent controlled updates from happending while mouse is moving\n        this.setState({ pending: true });\n\n        const position = this.getMousePosition(e);\n        this.start(i, position[0]);\n        addHandlers(this.getMouseEventMap());\n        pauseEvent(e);\n    };\n\n    // create the `touchstart` handler for the i-th thumb\n    createOnTouchStart = i => e => {\n        if (this.props.disabled || e.touches.length > 1) {\n            return;\n        }\n\n        // Prevent controlled updates from happending while touch is moving\n        this.setState({ pending: true });\n\n        const position = this.getTouchPosition(e);\n        this.startPosition = position;\n        // don't know yet if the user is trying to scroll\n        this.isScrolling = undefined;\n        this.start(i, position[0]);\n        addHandlers(this.getTouchEventMap());\n        stopPropagation(e);\n    };\n\n    handleResize = () => {\n        // setTimeout of 0 gives element enough time to have assumed its new size if\n        // it is being resized\n        const resizeTimeout = window.setTimeout(() => {\n            // drop this timeout from pendingResizeTimeouts to reduce memory usage\n            this.pendingResizeTimeouts.shift();\n            this.resize();\n        }, 0);\n\n        this.pendingResizeTimeouts.push(resizeTimeout);\n    };\n\n    resize() {\n        const { slider, thumb0: thumb } = this;\n        if (!slider || !thumb) {\n            return;\n        }\n\n        const sizeKey = this.sizeKey();\n\n        // For the slider size, we want to use the client width/height, excluding any borders\n        const sliderRect = slider.getBoundingClientRect();\n        const sliderSize = slider[sizeKey];\n        const sliderMax = sliderRect[this.posMaxKey()];\n        const sliderMin = sliderRect[this.posMinKey()];\n\n        // For the thumb size, we want to use the outer width/height, including any borders\n        const thumbRect = thumb.getBoundingClientRect();\n        const thumbSize = thumbRect[sizeKey.replace('client', '').toLowerCase()];\n\n        const upperBound = sliderSize - thumbSize;\n        const sliderLength = Math.abs(sliderMax - sliderMin);\n\n        if (\n            this.state.upperBound !== upperBound ||\n            this.state.sliderLength !== sliderLength ||\n            this.state.thumbSize !== thumbSize\n        ) {\n            this.setState({\n                upperBound,\n                sliderLength,\n                thumbSize,\n            });\n        }\n    }\n\n    // calculates the offset of a thumb in pixels based on its value.\n    calcOffset(value) {\n        const range = this.props.max - this.props.min;\n        if (range === 0) {\n            return 0;\n        }\n        const ratio = (value - this.props.min) / range;\n        return ratio * this.state.upperBound;\n    }\n\n    // calculates the value corresponding to a given pixel offset, i.e. the inverse of `calcOffset`.\n    calcValue(offset) {\n        const ratio = offset / this.state.upperBound;\n        return ratio * (this.props.max - this.props.min) + this.props.min;\n    }\n\n    calcOffsetFromPosition(position) {\n        const { slider } = this;\n\n        const sliderRect = slider.getBoundingClientRect();\n        const sliderMax = sliderRect[this.posMaxKey()];\n        const sliderMin = sliderRect[this.posMinKey()];\n\n        // The `position` value passed in is the mouse position based on the window height.\n        // The slider bounding rect is based on the viewport, so we must add the window scroll\n        // offset to normalize the values.\n        const windowOffset = window[`page${this.axisKey()}Offset`];\n        const sliderStart = windowOffset + (this.props.invert ? sliderMax : sliderMin);\n\n        let pixelOffset = position - sliderStart;\n        if (this.props.invert) {\n            pixelOffset = this.state.sliderLength - pixelOffset;\n        }\n        pixelOffset -= this.state.thumbSize / 2;\n        return pixelOffset;\n    }\n\n    // Snaps the nearest thumb to the value corresponding to `position`\n    // and calls `callback` with that thumb's index.\n    forceValueFromPosition(position, callback) {\n        const pixelOffset = this.calcOffsetFromPosition(position);\n        const closestIndex = this.getClosestIndex(pixelOffset);\n        const nextValue = trimAlignValue(this.calcValue(pixelOffset), this.props);\n\n        // Clone this.state.value since we'll modify it temporarily\n        // eslint-disable-next-line zillow/react/no-access-state-in-setstate\n        const value = this.state.value.slice();\n        value[closestIndex] = nextValue;\n\n        // Prevents the slider from shrinking below `props.minDistance`\n        for (let i = 0; i < value.length - 1; i += 1) {\n            if (value[i + 1] - value[i] < this.props.minDistance) {\n                return;\n            }\n        }\n\n        this.fireChangeEvent('onBeforeChange');\n        this.hasMoved = true;\n        this.setState({ value }, () => {\n            callback(closestIndex);\n            this.fireChangeEvent('onChange');\n        });\n    }\n\n    // clear all pending timeouts to avoid error messages after unmounting\n    clearPendingResizeTimeouts() {\n        do {\n            const nextTimeout = this.pendingResizeTimeouts.shift();\n\n            clearTimeout(nextTimeout);\n        } while (this.pendingResizeTimeouts.length);\n    }\n\n    start(i, position) {\n        const thumbRef = this[`thumb${i}`];\n        if (thumbRef) {\n            thumbRef.focus();\n        }\n\n        const { zIndices } = this.state;\n        // remove wherever the element is\n        zIndices.splice(zIndices.indexOf(i), 1);\n        // add to end\n        zIndices.push(i);\n\n        this.setState(prevState => ({\n            startValue: prevState.value[i],\n            startPosition: position !== undefined ? position : prevState.startPosition,\n            index: i,\n            zIndices,\n        }));\n    }\n\n    moveUpByStep(step = this.props.step) {\n        const oldValue = this.state.value[this.state.index];\n        const newValue = trimAlignValue(oldValue + step, this.props);\n        this.move(Math.min(newValue, this.props.max));\n    }\n\n    moveDownByStep(step = this.props.step) {\n        const oldValue = this.state.value[this.state.index];\n        const newValue = trimAlignValue(oldValue - step, this.props);\n        this.move(Math.max(newValue, this.props.min));\n    }\n\n    move(newValue) {\n        const { index, value } = this.state;\n        const { length } = value;\n\n        // Short circuit if the value is not changing\n        const oldValue = value[index];\n        if (newValue === oldValue) {\n            return;\n        }\n\n        // Trigger only before the first movement\n        if (!this.hasMoved) {\n            this.fireChangeEvent('onBeforeChange');\n        }\n        this.hasMoved = true;\n\n        // if \"pearling\" (= thumbs pushing each other) is disabled,\n        // prevent the thumb from getting closer than `minDistance` to the previous or next thumb.\n        const { pearling, max, min, minDistance } = this.props;\n        if (!pearling) {\n            if (index > 0) {\n                const valueBefore = value[index - 1];\n                if (newValue < valueBefore + minDistance) {\n                    // eslint-disable-next-line no-param-reassign\n                    newValue = valueBefore + minDistance;\n                }\n            }\n\n            if (index < length - 1) {\n                const valueAfter = value[index + 1];\n                if (newValue > valueAfter - minDistance) {\n                    // eslint-disable-next-line no-param-reassign\n                    newValue = valueAfter - minDistance;\n                }\n            }\n        }\n\n        value[index] = newValue;\n\n        // if \"pearling\" is enabled, let the current thumb push the pre- and succeeding thumbs.\n        if (pearling && length > 1) {\n            if (newValue > oldValue) {\n                this.pushSucceeding(value, minDistance, index);\n                trimSucceeding(length, value, minDistance, max);\n            } else if (newValue < oldValue) {\n                this.pushPreceding(value, minDistance, index);\n                trimPreceding(length, value, minDistance, min);\n            }\n        }\n\n        // Normally you would use `shouldComponentUpdate`,\n        // but since the slider is a low-level component,\n        // the extra complexity might be worth the extra performance.\n        this.setState({ value }, this.fireChangeEvent.bind(this, 'onChange'));\n    }\n\n    pushSucceeding(value, minDistance, index) {\n        let i;\n        let padding;\n        for (\n            i = index, padding = value[i] + minDistance;\n            value[i + 1] !== null && padding > value[i + 1];\n            i += 1, padding = value[i] + minDistance\n        ) {\n            // eslint-disable-next-line no-param-reassign\n            value[i + 1] = alignValue(padding, this.props);\n        }\n    }\n\n    pushPreceding(value, minDistance, index) {\n        for (\n            let i = index, padding = value[i] - minDistance;\n            value[i - 1] !== null && padding < value[i - 1];\n            i -= 1, padding = value[i] - minDistance\n        ) {\n            // eslint-disable-next-line no-param-reassign\n            value[i - 1] = alignValue(padding, this.props);\n        }\n    }\n\n    axisKey() {\n        if (this.props.orientation === 'vertical') {\n            return 'Y';\n        }\n        // Defaults to 'horizontal';\n        return 'X';\n    }\n\n    orthogonalAxisKey() {\n        if (this.props.orientation === 'vertical') {\n            return 'X';\n        }\n        // Defaults to 'horizontal'\n        return 'Y';\n    }\n\n    posMinKey() {\n        if (this.props.orientation === 'vertical') {\n            return this.props.invert ? 'bottom' : 'top';\n        }\n        // Defaults to 'horizontal'\n        return this.props.invert ? 'right' : 'left';\n    }\n\n    posMaxKey() {\n        if (this.props.orientation === 'vertical') {\n            return this.props.invert ? 'top' : 'bottom';\n        }\n        // Defaults to 'horizontal'\n        return this.props.invert ? 'left' : 'right';\n    }\n\n    sizeKey() {\n        if (this.props.orientation === 'vertical') {\n            return 'clientHeight';\n        }\n        // Defaults to 'horizontal'\n        return 'clientWidth';\n    }\n\n    fireChangeEvent(event) {\n        if (this.props[event]) {\n            this.props[event](prepareOutValue(this.state.value), this.state.index);\n        }\n    }\n\n    buildThumbStyle(offset, i) {\n        const style = {\n            position: 'absolute',\n            touchAction: 'none',\n            willChange: this.state.index >= 0 ? this.posMinKey() : undefined,\n            zIndex: this.state.zIndices.indexOf(i) + 1,\n        };\n        style[this.posMinKey()] = `${offset}px`;\n        return style;\n    }\n\n    buildTrackStyle(min, max) {\n        const obj = {\n            position: 'absolute',\n            willChange:\n                this.state.index >= 0 ? `${this.posMinKey()},${this.posMaxKey()}` : undefined,\n        };\n        obj[this.posMinKey()] = min;\n        obj[this.posMaxKey()] = max;\n        return obj;\n    }\n\n    buildMarkStyle(offset) {\n        return {\n            position: 'absolute',\n            [this.posMinKey()]: offset,\n        };\n    }\n\n    renderThumb = (style, i) => {\n        const className = `${this.props.thumbClassName} ${this.props.thumbClassName}-${i} ${\n            this.state.index === i ? this.props.thumbActiveClassName : ''\n        }`;\n\n        const props = {\n            'ref': r => {\n                this[`thumb${i}`] = r;\n            },\n            'key': `${this.props.thumbClassName}-${i}`,\n            className,\n            style,\n            'onMouseDown': this.createOnMouseDown(i),\n            'onTouchStart': this.createOnTouchStart(i),\n            'onFocus': this.createOnKeyDown(i),\n            'tabIndex': 0,\n            'role': 'slider',\n            'aria-orientation': this.props.orientation,\n            'aria-valuenow': this.state.value[i],\n            'aria-valuemin': this.props.min,\n            'aria-valuemax': this.props.max,\n            'aria-label': Array.isArray(this.props.ariaLabel)\n                ? this.props.ariaLabel[i]\n                : this.props.ariaLabel,\n            'aria-labelledby': Array.isArray(this.props.ariaLabelledby)\n                ? this.props.ariaLabelledby[i]\n                : this.props.ariaLabelledby,\n        };\n\n        const state = {\n            index: i,\n            value: prepareOutValue(this.state.value),\n            valueNow: this.state.value[i],\n        };\n\n        if (this.props.ariaValuetext) {\n            props['aria-valuetext'] =\n                typeof this.props.ariaValuetext === 'string'\n                    ? this.props.ariaValuetext\n                    : this.props.ariaValuetext(state);\n        }\n\n        return this.props.renderThumb(props, state);\n    };\n\n    renderThumbs(offset) {\n        const { length } = offset;\n\n        const styles = [];\n        for (let i = 0; i < length; i += 1) {\n            styles[i] = this.buildThumbStyle(offset[i], i);\n        }\n\n        const res = [];\n        for (let i = 0; i < length; i += 1) {\n            res[i] = this.renderThumb(styles[i], i);\n        }\n        return res;\n    }\n\n    renderTrack = (i, offsetFrom, offsetTo) => {\n        const props = {\n            key: `${this.props.trackClassName}-${i}`,\n            className: `${this.props.trackClassName} ${this.props.trackClassName}-${i}`,\n            style: this.buildTrackStyle(offsetFrom, this.state.upperBound - offsetTo),\n        };\n        const state = {\n            index: i,\n            value: prepareOutValue(this.state.value),\n        };\n        return this.props.renderTrack(props, state);\n    };\n\n    renderTracks(offset) {\n        const tracks = [];\n        const lastIndex = offset.length - 1;\n\n        tracks.push(this.renderTrack(0, 0, offset[0]));\n\n        for (let i = 0; i < lastIndex; i += 1) {\n            tracks.push(this.renderTrack(i + 1, offset[i], offset[i + 1]));\n        }\n\n        tracks.push(this.renderTrack(lastIndex + 1, offset[lastIndex], this.state.upperBound));\n\n        return tracks;\n    }\n\n    renderMarks() {\n        let { marks } = this.props;\n\n        const range = this.props.max - this.props.min + 1;\n\n        if (typeof marks === 'boolean') {\n            marks = Array.from({ length: range }).map((_, key) => key);\n        } else if (typeof marks === 'number') {\n            marks = Array.from({ length: range })\n                .map((_, key) => key)\n                .filter(key => key % marks === 0);\n        }\n\n        return marks\n            .map(parseFloat)\n            .sort((a, b) => a - b)\n            .map(mark => {\n                const offset = this.calcOffset(mark);\n\n                const props = {\n                    key: mark,\n                    className: this.props.markClassName,\n                    style: this.buildMarkStyle(offset),\n                };\n\n                return this.props.renderMark(props);\n            });\n    }\n\n    render() {\n        const offset = [];\n        const { value } = this.state;\n        const l = value.length;\n        for (let i = 0; i < l; i += 1) {\n            offset[i] = this.calcOffset(value[i], i);\n        }\n\n        const tracks = this.props.withTracks ? this.renderTracks(offset) : null;\n        const thumbs = this.renderThumbs(offset);\n        const marks = this.props.marks ? this.renderMarks() : null;\n\n        return React.createElement(\n            'div',\n            {\n                ref: r => {\n                    this.slider = r;\n                    this.resizeElementRef.current = r;\n                },\n                style: { position: 'relative' },\n                className: this.props.className + (this.props.disabled ? ' disabled' : ''),\n                onMouseDown: this.onSliderMouseDown,\n                onClick: this.onSliderClick,\n            },\n            tracks,\n            thumbs,\n            marks\n        );\n    }\n}\n\nexport default ReactSlider;\n"]},"metadata":{},"sourceType":"script"}